{"version":3,"file":"typo.js","sources":["../../scratch/main/index.js","../../scratch/main/typo.js"],"sourcesContent":["// BUILD_INCLUDE(\"typo/legacy/imports.js\")\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nexport class Typo {\n    //#region Constructor\n    /**\n     * Typo constructor.\n     * @param {string} [dictionary] The locale code of the dictionary being used.e.g.,\n     * \"en_US\".This is only used to auto - load dictionaries.\n     * @param {String} [affData] The data from the dictionary 's .aff file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.aff\n     * file will be loaded automatically from\n     * lib / typo / dictionaries / [dictionary] / [dictionary].aff\n     * In other environments,it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].aff\n     * @param {String} [wordsData] The data from the dictionary 's .dic file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.dic\n     * file will be loaded automatically from * lib / typo / dictionaries / [dictionary] / [dictionary].dic\n     * In other environments, it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].dic\n     * @param {Object} [settings] Constructor settings.Available properties are :\n     * {String}[dictionaryPath] : path to load dictionary from in non - chrome\n     * environment.\n     * {Object}[flags] : flag information.\n     * {Boolean}[asyncLoad] : If true, affData and wordsData will be loaded\n     * asynchronously.\n     * {Function}[loadedCallback] : Called when both affData and wordsData\n     * have been loaded.Only used if asyncLoad is set to true.The parameter\n     * is the instantiated Typo object.\n     */\n    constructor(dictionary, affData, wordsData, settings) {\n        this.ERR_NOT_LOAD = \"Dictionary not loaded\";\n        this.ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n        this.lDictionary = '';\n        /**\n        * Object that will contain and entry of IRuleCodes for each\n        * dynamically added key\n        */\n        this.rules = {};\n        // dictionaryTable seems to be an object full or arrays for elements in the dom.\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = new Array();\n        this.memoized = {};\n        this.loaded = false;\n        this.options = settings || { asyncLoad: false, flags: {} };\n        if (settings !== undefined && settings !== null) {\n            if (settings.flags !== undefined) {\n                this.flags = settings.flags;\n            }\n            else {\n                this.flags = {};\n            }\n        }\n        else {\n            this.flags = {};\n        }\n        const readDataFile = async (url) => {\n            const response = this._readFile(url, null, this.options.asyncLoad);\n            return response;\n            // response.then(text => {\n            // \tsetFunc(text);\n            // }).catch(error => {\n            // \tconsole.error(error);\n            // });\n        };\n        const init = async (dic, aff, wData) => {\n            const setAffData = (data) => {\n                aff = data;\n                if (wData) {\n                    setup();\n                }\n            };\n            const setWordsData = (data) => {\n                wData = data;\n                if (aff) {\n                    setup();\n                }\n            };\n            const setup = () => {\n                if (aff === undefined) {\n                    return;\n                }\n                if (wData === undefined) {\n                    return;\n                }\n                this.rules = this._parseAFF(aff);\n                // Save the rule codes that are used in compound rules.\n                this.compoundRuleCodes = {};\n                for (const rule of this.compoundRules) {\n                    if (typeof rule === 'string') {\n                        for (let j = 0; j < rule.length; j++) {\n                            this.compoundRuleCodes[rule.charAt(j)] = [];\n                        }\n                    }\n                }\n                // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n                // will do the work of saving the list of words that are compound-only.\n                if (this.flags.ONLYINCOMPOUND) {\n                    this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = [];\n                }\n                this.dictionaryTable = this._parseDIC(wData);\n                // Get rid of any codes from the compound rule codes that are never used\n                // (or that were special regex characters).  Not especially necessary...\n                for (const iKey in this.compoundRuleCodes) {\n                    if (Object.prototype.hasOwnProperty.call(this.compoundRuleCodes, iKey)) {\n                        if (this.compoundRuleCodes[iKey].length === 0) {\n                            delete this.compoundRuleCodes[iKey];\n                        }\n                    }\n                }\n                // Build the full regular expressions for each compound rule.\n                // I have a feeling (but no confirmation yet) that this method of\n                // testing for compound words is probably slow.\n                i = 0;\n                for (const ruleText of this.compoundRules) {\n                    let expressionText = \"\";\n                    if (typeof ruleText === 'string') {\n                        for (const character of ruleText) {\n                            if (character in this.compoundRuleCodes) {\n                                expressionText += \"(\" + this.compoundRuleCodes[character].join(\"|\") + \")\";\n                            }\n                            else {\n                                expressionText += character;\n                            }\n                        }\n                        this.compoundRules[i] = new RegExp(expressionText, \"i\");\n                        i++;\n                    }\n                }\n                this.loaded = true;\n                if (this.options.asyncLoad && this.options.loadedCallback) {\n                    this.options.loadedCallback(this);\n                }\n            };\n            const isChromeExt = () => {\n                if (typeof window.chrome?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            const isBrowserExt = () => {\n                if (typeof window.browser?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            let path;\n            let pLoadDataAff;\n            let pLoadDataDic;\n            // Loop-control variables.\n            let i;\n            if (dic) {\n                this.lDictionary = dic;\n                // If the data is preloaded, just setup the Typo object.\n                if (aff && wData) {\n                    setup();\n                }\n                // Loading data for Browser extentions.\n                else if (typeof window !== 'undefined' && (isChromeExt() === true || isBrowserExt() === true)) {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else {\n                        path = \"typo/dictionaries\";\n                    }\n                    let getURL;\n                    if (isChromeExt() === true) {\n                        getURL = window.chrome.runtime.getURL;\n                    }\n                    else {\n                        getURL = window.browser.runtime.getURL;\n                    }\n                    if (this.options.asyncLoad === true) {\n                        if (!aff) {\n                            pLoadDataAff = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".aff\"))\n                                .then(affD => {\n                                setAffData(affD);\n                            });\n                        }\n                        if (!wData) {\n                            pLoadDataDic = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".dic\"))\n                                .then(wordsD => {\n                                setWordsData(wordsD);\n                            });\n                        }\n                    }\n                    else {\n                        if (!aff) {\n                            pLoadDataAff = await readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".aff\"))\n                                .then(affD => {\n                                setAffData(affD);\n                            });\n                        }\n                        if (!wData) {\n                            pLoadDataDic = await readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".dic\"))\n                                .then(wordsD => {\n                                setWordsData(wordsD);\n                            });\n                        }\n                    }\n                }\n                else {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else if (typeof __dirname !== 'undefined') {\n                        path = __dirname + '/dictionaries';\n                    }\n                    else {\n                        path = './dictionaries';\n                    }\n                    if (this.options.asyncLoad === true) {\n                        if (!aff) {\n                            pLoadDataAff = readDataFile(path + \"/\" + dic + \"/\" + dic + \".aff\")\n                                .then(affD => {\n                                setAffData(affD);\n                            });\n                        }\n                        if (!wData) {\n                            pLoadDataDic = readDataFile(path + \"/\" + dic + \"/\" + dic + \".dic\")\n                                .then(wordsD => {\n                                setWordsData(wordsD);\n                            });\n                        }\n                    }\n                    else {\n                        if (!aff) {\n                            pLoadDataAff = await readDataFile(path + \"/\" + dic + \"/\" + dic + \".aff\")\n                                .then(affD => {\n                                setAffData(affD);\n                            });\n                        }\n                        if (!wData) {\n                            pLoadDataDic = await readDataFile(path + \"/\" + dic + \"/\" + dic + \".dic\")\n                                .then(wordsD => {\n                                setWordsData(wordsD);\n                            });\n                        }\n                    }\n                }\n            }\n            return new Promise((resolve, reject) => {\n                Promise.all([pLoadDataDic, pLoadDataAff])\n                    .then(() => { resolve(true); })\n                    .catch(() => { reject(false); });\n            });\n        };\n        this.ready = new Promise((resolve, reject) => {\n            init(dictionary, affData, wordsData)\n                .then(() => { resolve(this); })\n                .catch(reject);\n        });\n        // if (this.options.asyncLoad === true) {\n        // \treturn (async (): Typo => {\n        // \t\t// await anything you want\n        // \t\treturn this; // Return the newly-created instance\n        // \t}).call(this);\n        // } else {\n    }\n    //#endregion Constructor\n    //#region  Properties\n    get Ready() {\n        return this.ready;\n    }\n    get dictionary() {\n        if (this.lDictionary === '') {\n            return null;\n        }\n        return this.lDictionary;\n    }\n    //#endregion properties\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load(obj) {\n        for (const i in obj) {\n            if (obj.hasOwnProperty(i) && Object(this).hasOwnProperty(i)) {\n                const val = obj[i];\n                Object.defineProperty(this, i.toString(), {\n                    value: val,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n                // this[i] = obj[i];\n            }\n        }\n        return this;\n    }\n    // #region _readFile function\n    /**\n     * Read the contents of a file.\n     *\n     * @param {String} path The path (relative) to the file.\n     * @param {String|null} charset The expected charset of the file, If null default to utf8\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     * files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     * always returned.\n     */\n    _readFile(path, charset, async = false) {\n        charset = charset || \"utf8\";\n        if (typeof fetch === 'function') {\n            const requestHeaders = new Headers();\n            requestHeaders.set('Content-Type', \"text/plain; charset=\" + charset);\n            const aw = async (aPath) => {\n                const response = await fetch(aPath, {\n                    method: 'GET',\n                    headers: requestHeaders\n                });\n                return response.text();\n            };\n            if (!async) {\n                return aw(path);\n            }\n            const fetchIt = (p) => {\n                return fetch(p, {\n                    method: 'GET',\n                    headers: requestHeaders\n                }).then((response) => response.text());\n            };\n            return fetchIt(path);\n        }\n        else if (typeof XMLHttpRequest !== 'undefined') {\n            const req = new XMLHttpRequest();\n            req.open(\"GET\", path, async);\n            if (req.overrideMimeType) {\n                req.overrideMimeType(\"text/plain; charset=\" + charset);\n            }\n            if (async) {\n                const promise = new Promise(function (resolve, reject) {\n                    req.onload = function () {\n                        if (req.status === 200) {\n                            resolve(req.responseText);\n                        }\n                        else {\n                            reject(req.statusText);\n                        }\n                    };\n                    req.onerror = function () {\n                        reject(req.statusText);\n                    };\n                });\n                req.send(null);\n                return promise;\n            }\n            req.send(null);\n            return Promise.resolve(req.responseText);\n        }\n        else if (typeof require !== 'undefined') { // Node.js\n            const fs = require(\"fs\");\n            let result = '';\n            let err = null;\n            try {\n                if (fs.existsSync(path)) {\n                    result = fs.readFileSync(path, charset);\n                }\n                else {\n                    console.log(\"Path \" + path + \" does not exist.\");\n                }\n            }\n            catch (e) {\n                err = e;\n            }\n            if (err !== null) {\n                return Promise.reject(err);\n            }\n            return Promise.resolve(result);\n        }\n        return Promise.reject(new Error('An Error occured getting dictionary'));\n    }\n    // #endregion _readFile function\n    // #region _parseAFF\n    _parseAFF(data) {\n        const rules = {};\n        let line;\n        let subline;\n        let numEntries;\n        let lineParts;\n        let i;\n        let j;\n        let numIlen;\n        let numJlen;\n        // Remove comment lines\n        data = this._removeAffixComments(data);\n        const lines = data.split(/\\r?\\n/);\n        for (i = 0, numIlen = lines.length; i < numIlen; i++) {\n            line = lines[i];\n            const definitionParts = line.split(/\\s+/);\n            const ruleType = definitionParts[0];\n            if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                const ruleCode = definitionParts[1];\n                const combineable = definitionParts[2];\n                numEntries = parseInt(definitionParts[3], 10);\n                const entries = [];\n                for (j = i + 1, numJlen = i + 1 + numEntries; j < numJlen; j++) {\n                    subline = lines[j];\n                    lineParts = subline.split(/\\s+/);\n                    const charactersToRemove = lineParts[2];\n                    const additionParts = lineParts[3].split(\"/\");\n                    let charactersToAdd = additionParts[0];\n                    if (charactersToAdd === \"0\")\n                        charactersToAdd = \"\";\n                    const continuationClasses = this.parseRuleCodes(additionParts[1]);\n                    const regexToMatch = lineParts[4];\n                    const entry = {};\n                    entry.add = charactersToAdd;\n                    if (continuationClasses.length > 0)\n                        entry.continuationClasses = continuationClasses;\n                    if (regexToMatch !== \".\") {\n                        if (ruleType === \"SFX\") {\n                            entry.match = new RegExp(regexToMatch + \"$\");\n                        }\n                        else {\n                            entry.match = new RegExp(\"^\" + regexToMatch);\n                        }\n                    }\n                    if (charactersToRemove !== \"0\") {\n                        if (ruleType === \"SFX\") {\n                            entry.remove = new RegExp(charactersToRemove + \"$\");\n                        }\n                        else {\n                            entry.remove = new RegExp(charactersToRemove);\n                        }\n                    }\n                    entries.push(entry);\n                }\n                rules[ruleCode] = {\n                    \"type\": ruleType,\n                    \"combineable\": (combineable === \"Y\"),\n                    \"entries\": entries\n                };\n                i += numEntries;\n            }\n            else if (ruleType === \"COMPOUNDRULE\") {\n                numEntries = parseInt(definitionParts[1], 10);\n                for (j = i + 1, numJlen = i + 1 + numEntries; j < numJlen; j++) {\n                    line = lines[j];\n                    lineParts = line.split(/\\s+/);\n                    // When the regexp parameter is a string or a number,\n                    // it is implicitly converted to a RegExp by using new RegExp(regexp).\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\n                    this.compoundRules.push(lineParts[1]);\n                }\n                i += numEntries;\n            }\n            else if (ruleType === \"REP\") {\n                lineParts = line.split(/\\s+/);\n                if (lineParts.length === 3) {\n                    this.replacementTable.push([\n                        lineParts[1], lineParts[2]\n                    ]);\n                }\n            }\n            else {\n                // ONLYINCOMPOUND\n                // COMPOUNDMIN\n                // FLAG\n                // KEEPCASE\n                // NEEDAFFIX\n                this.flags[ruleType] = definitionParts[1];\n            }\n        }\n        return rules;\n    }\n    // #endregion _parseAFF\n    // #region _removeAffixComments\n    /**\n         * Removes comment lines and then cleans up blank lines and trailing whitespace.\n         *\n         * @param {String} data The data from an affix file.\n         * @return {String} The cleaned-up data.\n         */\n    _removeAffixComments(data) {\n        // Remove comments\n        // This used to remove any string starting with '#' up to the end of the line,\n        // but some COMPOUNDRULE definitions include '#' as part of the rule.\n        // I haven't seen any affix files that use comments on the same line as real data,\n        // so I don't think this will break anything.\n        const str = data.replace(/^\\s*#.*$/mg, \"\")\n            // Trim each line\n            .replace(/^\\s\\s*/m, '')\n            .replace(/\\s\\s*$/m, '')\n            // Remove blank lines.\n            .replace(/\\n{2,}/g, \"\\n\")\n            // Trim the entire string\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n        return str;\n    }\n    // #endregion _removeAffixComments\n    // #region _parseDIC\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n    * The dictionary table looks similar to the folowng.\n    * Note the dictionary table can have more than 20,000 entries\n    ````js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n     ````\n     */\n    _parseDIC(data) {\n        data = this._removeDicComments(data);\n        const lines = data.split(/\\r?\\n/);\n        const dictionaryTable = {};\n        /**\n         * Pushes a string array on dictionary table\n         * @param {strng} key The key to add or append rules to\n         * @param {string[]} rules string array of rules to add.\n         *\n         * The dictionary table looks similar to the folowng.\n         * Note the dictionary table can have more than 20,000 entries\n         ```js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n         ```\n         */\n        const addWord = (key, rules) => {\n            if (!dictionaryTable.hasOwnProperty(key)) {\n                dictionaryTable[key] = null;\n            }\n            if (rules.length > 0) {\n                let el = dictionaryTable[key];\n                if (el === null || el === undefined) {\n                    el = [];\n                    dictionaryTable[key] = el;\n                }\n                el.push(rules);\n            }\n        };\n        // The first line is the number of words in the dictionary.\n        for (let i = 1; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) { // Ignore empty lines.\n                continue;\n            }\n            const parts = line.split(\"/\", 2);\n            const word = parts[0];\n            // Now for each affix rule, generate that form of the word.\n            if (parts.length > 1) {\n                const ruleCodesArray = this.parseRuleCodes(parts[1]);\n                // Save the ruleCodes for compound word situations.\n                if (!(this.flags.NEEDAFFIX)\n                    || (this.flags.NEEDAFFIX && ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1)) {\n                    addWord(word, ruleCodesArray);\n                }\n                for (let j = 0; j < ruleCodesArray.length; j++) {\n                    const code = ruleCodesArray[j];\n                    const rule = this.rules[code];\n                    if (rule) {\n                        const newWords = this._applyRule(word, rule);\n                        for (const newWord of newWords) {\n                            addWord(newWord, []);\n                            if (rule.combineable) {\n                                for (let k = j + 1; k < ruleCodesArray.length; k++) {\n                                    const combineCode = ruleCodesArray[k];\n                                    const combineRule = this.rules[combineCode];\n                                    if (combineRule) {\n                                        if (combineRule.combineable && (rule.type !== combineRule.type)) {\n                                            const otherNewWords = this._applyRule(newWord, combineRule);\n                                            for (const otherNewWord of otherNewWords) {\n                                                addWord(otherNewWord, []);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (code in this.compoundRuleCodes) {\n                        this.compoundRuleCodes[code].push(word);\n                    }\n                }\n            }\n            else {\n                addWord(word.trim(), []);\n            }\n        }\n        return dictionaryTable;\n    }\n    // #endregion _parseDIC\n    // #region _removeDicComments\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeDicComments(data) {\n        // I can't find any official documentation on it, but at least the de_DE\n        // dictionary uses tab-indented lines as comments.\n        // Remove comments\n        return data.replace(/^\\t.*$/mg, \"\");\n    }\n    // #endregion _removeDicComments\n    // #region _applyRule\n    _applyRule(word, rule) {\n        const entries = rule.entries;\n        let newWords = [];\n        for (const entry of entries) {\n            if (!entry.match || word.match(entry.match)) {\n                let newWord = word;\n                if (entry.remove) {\n                    newWord = newWord.replace(entry.remove, \"\");\n                }\n                if (rule.type === \"SFX\") {\n                    newWord = newWord + entry.add;\n                }\n                else {\n                    newWord = entry.add + newWord;\n                }\n                newWords.push(newWord);\n                if (\"continuationClasses\" in entry) {\n                    for (const continuationRule of entry.continuationClasses) {\n                        if (continuationRule) {\n                            newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                        }\n                        /*\n                        else {\n                            // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                            // I think the author mistakenly supplied lower-case rule codes instead\n                            // of upper-case.\n                        }\n                        */\n                    }\n                }\n            }\n        }\n        return newWords;\n    }\n    // #endregion _applyRule\n    //#region init\n    //#endregion init\n    // #region parseRuleCodes\n    /**\n     *\n     * @param {string} textCodes\n     */\n    parseRuleCodes(textCodes) {\n        if (!textCodes || this.flags === undefined) {\n            return [];\n        }\n        else if (!(this.flags.FLAG)) {\n            return textCodes.split(\"\");\n        }\n        else if (this.flags.FLAG === \"long\") {\n            const pFlags = [];\n            for (let i = 0; i < textCodes.length; i += 2) {\n                pFlags.push(textCodes.substr(i, 2));\n            }\n            return pFlags;\n        }\n        else if (this.flags.FLAG === \"num\") {\n            return textCodes.split(\",\");\n        }\n        return [];\n    }\n    // #endregion parseRuleCodes\n    //#region check Methods\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {string} aWord The word to check.\n     * @returns {boolean}\n     */\n    check(aWord) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (aWord.length === 0) {\n            return false;\n        }\n        // Remove leading and trailing whitespace\n        const trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        if (this.checkExact(trimmedWord)) {\n            return true;\n        }\n        // The exact word is not in the dictionary.\n        if (trimmedWord.toUpperCase() === trimmedWord) {\n            // The word was supplied in all uppercase.\n            // Check for a capitalized form of the word.\n            const capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n            if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            if (this.checkExact(capitalizedWord)) {\n                return true;\n            }\n        }\n        const lowercaseWord = trimmedWord.toLowerCase();\n        if (lowercaseWord !== trimmedWord) {\n            if (this.hasFlag(lowercaseWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            // Check for a lowercase form\n            if (this.checkExact(lowercaseWord)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region checkExact method\n    /**\n    * Checks whether a word exists in the current dictionary.\n    *\n    * @param {string} word The word to check.\n    * @returns {boolean}\n    */\n    checkExact(word) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (word.length === 0) {\n            return false;\n        }\n        const ruleCodes = this.dictionaryTable[word];\n        if (typeof ruleCodes === 'undefined') { // Check if this might be a compound word.\n            if ((this.flags.COMPOUNDMIN) && (word.length >= this.flags.COMPOUNDMIN)) {\n                for (const rule of this.compoundRules) {\n                    if (word.match(rule)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        else if (ruleCodes === null) {\n            // a null (but not undefined) value for an entry in the dictionary table\n            // means that the word is in the dictionary but has no flags.\n            return true;\n        }\n        else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n            for (const ruleCode of ruleCodes) {\n                if ((ruleCode !== null)\n                    && !(this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCode))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region hasFlag\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {string} word The word in question.\n     * @param {string} strFlag The flag in question.\n     * @param {any} [wordFlags]\n     * @return {boolean}\n     */\n    hasFlag(word, strFlag, wordFlags) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        const flattenArr = (arr) => {\n            const ar = [];\n            for (const a of arr)\n                for (const s of a)\n                    ar.push(s);\n            return ar;\n        };\n        if (strFlag in this.flags) {\n            if (typeof wordFlags === 'undefined') {\n                const tableItem = this.dictionaryTable[word];\n                if (tableItem !== undefined && tableItem !== null) {\n                    wordFlags = flattenArr(tableItem); // only interested in index of a key\n                }\n                else {\n                    wordFlags = [];\n                }\n            }\n            if (wordFlags && wordFlags.indexOf(this.flags[strFlag]) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion hasFlag\n    //#region suggest method\n    /**\n    * Returns a list of suggestions for a misspelled word.\n    *\n    * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n    * This suggestor is primitive, but it works.\n    *\n    * @param {string} word The misspelling.\n    * @param {number} [limit=5] The maximum number of suggestions to return.\n    * @returns {string[]} The array of suggestions.\n    */\n    suggest(word, limit = 5) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (this.memoized.hasOwnProperty(word)) {\n            const memoizedLimit = this.memoized[word]['limit'];\n            // Only return the cached list if it's big enough or if there weren't enough suggestions\n            // to fill a smaller limit.\n            if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n                return this.memoized[word]['suggestions'].slice(0, limit);\n            }\n        }\n        if (this.check(word))\n            return [];\n        // Check the replacement table.\n        for (const replacementEntry of this.replacementTable) {\n            if (word.indexOf(replacementEntry[0]) !== -1) {\n                const correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                if (this.check(correctedWord)) {\n                    return [correctedWord];\n                }\n            }\n        }\n        /*\n        if (!self.alphabet) {\n            // Use the alphabet as implicitly defined by the words in the dictionary.\n            var alphaHash = {};\n            \n            for (var i in self.dictionaryTable) {\n                for (var j = 0, _len = i.length; j < _len; j++) {\n                    alphaHash[i[j]] = true;\n                }\n            }\n            \n            for (var i in alphaHash) {\n                self.alphabet += i;\n            }\n            \n            var alphaArray = self.alphabet.split(\"\");\n            alphaArray.sort();\n            self.alphabet = alphaArray.join(\"\");\n        }\n        */\n        /**\n         * Returns a hash keyed by all of the strings that can be made\n         * by making a single edit to the word (or words in) `words`\n         * The value of each entry is the number of unique ways that the\n         * resulting word can be made.\n         * @param words words Either a hash keyed by words or a string word to operate on.\n         * @param {boolean} [knownOnly=false] known_only Whether this function should ignore strings that are not in the dictionary.\n         */\n        const edits1 = (words, knownOnly = false) => {\n            const rv = {};\n            let i;\n            let j;\n            let numLen;\n            let numJlen;\n            let strEdit;\n            if (typeof words === 'string') {\n                const wrd = words;\n                words = {};\n                words[wrd] = 1;\n            }\n            for (const wrd in words) {\n                if (Object.prototype.hasOwnProperty.call(words, wrd)) {\n                    // const wd = words[wd];\n                    for (i = 0, numLen = wrd.length + 1; i < numLen; i++) {\n                        const strSub = [wrd.substring(0, i), wrd.substring(i)];\n                        if (strSub[1]) {\n                            strEdit = strSub[0] + strSub[1].substring(1);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        // Eliminate transpositions of identical letters\n                        if (strSub[1].length > 1 && strSub[1][1] !== strSub[1][0]) {\n                            strEdit = strSub[0] + strSub[1][1] + strSub[1][0] + strSub[1].substring(2);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                // Eliminate replacement of a letter by itself\n                                if (this.ALPHABET[j] !== strSub[1].substring(0, 1)) {\n                                    strEdit = strSub[0] + this.ALPHABET[j] + strSub[1].substring(1);\n                                    if (!knownOnly || this.check(strEdit)) {\n                                        if (!(strEdit in rv)) {\n                                            rv[strEdit] = 1;\n                                        }\n                                        else {\n                                            rv[strEdit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                strEdit = strSub[0] + this.ALPHABET[j] + strSub[1];\n                                if (!knownOnly || this.check(strEdit)) {\n                                    if (!(strEdit in rv)) {\n                                        rv[strEdit] = 1;\n                                    }\n                                    else {\n                                        rv[strEdit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return rv;\n        };\n        const correct = (wrd) => {\n            // Get the edit-distance-1 and edit-distance-2 forms of this word.\n            const ed1 = edits1(wrd);\n            const ed2 = edits1(ed1, true);\n            // Sort the edits based on how many different ways they were created.\n            const weightedCorrections = ed2;\n            for (const ed1word in ed1) {\n                if (!this.check(ed1word)) {\n                    continue;\n                }\n                if (ed1word in weightedCorrections) {\n                    weightedCorrections[ed1word] += ed1[ed1word];\n                }\n                else {\n                    weightedCorrections[ed1word] = ed1[ed1word];\n                }\n            }\n            let i;\n            const sortedCorrections = [];\n            for (const j in weightedCorrections) {\n                // if (Object.prototype.hasOwnProperty.call(weighted_corrections, i)) {\n                // \tsorted_corrections.push([i, weighted_corrections[i]]);\n                // }\n                if (weightedCorrections.hasOwnProperty(j)) {\n                    sortedCorrections.push([j, weightedCorrections[j]]);\n                }\n            }\n            const sorter = (a, b) => {\n                // frist eleement is the word if a and b\n                // second element of a and b is numeric values\n                const aVal = a[1];\n                const bVal = b[1];\n                if (aVal < bVal) {\n                    return -1;\n                }\n                else if (aVal > bVal) {\n                    return 1;\n                }\n                // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                return b[0].toString().localeCompare(a[0].toString());\n            };\n            sortedCorrections.sort(sorter).reverse();\n            const rv = [];\n            let capitalizationScheme = \"lowercase\";\n            if (wrd.toUpperCase() === wrd) {\n                capitalizationScheme = \"uppercase\";\n            }\n            else if (wrd.substr(0, 1).toUpperCase() + wrd.substr(1).toLowerCase() === wrd) {\n                capitalizationScheme = \"capitalized\";\n            }\n            let workingLimit = limit;\n            for (i = 0; i < Math.min(workingLimit, sortedCorrections.length); i++) {\n                let sortString = sortedCorrections[i][0].toString();\n                let update = false;\n                if (\"uppercase\" === capitalizationScheme) {\n                    sortString = sortString.toUpperCase();\n                    update = true;\n                }\n                else if (\"capitalized\" === capitalizationScheme) {\n                    sortString = sortString.substr(0, 1).toUpperCase() + sortString.substr(1);\n                    update = true;\n                }\n                if (!this.hasFlag(sortString, \"NOSUGGEST\") && rv.indexOf(sortString) === -1) {\n                    rv.push(sortString);\n                }\n                else {\n                    // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                    workingLimit++;\n                }\n                if (update) {\n                    sortedCorrections[i][0] = sortString;\n                }\n            }\n            return rv;\n        };\n        this.memoized[word] = {\n            'suggestions': correct(word),\n            'limit': limit\n        };\n        return this.memoized[word]['suggestions'];\n    }\n}\n","import { Typo as T } from './index';\nif (typeof window !== 'undefined' && window.Typo === undefined) {\n    window.Typo = T;\n}\n"],"names":["Typo","dictionary","affData","wordsData","settings","ERR_NOT_LOAD","ALPHABET","lDictionary","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","Array","memoized","loaded","options","asyncLoad","flags","undefined","readDataFile","url","response","_readFile","init","dic","aff","wData","setAffData","data","setup","setWordsData","_parseAFF","rule","j","length","charAt","ONLYINCOMPOUND","_parseDIC","iKey","Object","prototype","hasOwnProperty","call","i","ruleText","expressionText","character","join","RegExp","loadedCallback","isChromeExt","window","chrome","runtime","getURL","isBrowserExt","browser","path","pLoadDataAff","pLoadDataDic","dictionaryPath","then","affD","wordsD","__dirname","Promise","resolve","reject","all","catch","ready","obj","val","defineProperty","toString","value","writable","enumerable","configurable","charset","async","fetch","requestHeaders","Headers","set","aw","aPath","method","headers","text","fetchIt","p","XMLHttpRequest","req","open","overrideMimeType","promise","onload","status","responseText","statusText","onerror","send","require","fs","result","err","existsSync","readFileSync","console","log","e","Error","line","subline","numEntries","lineParts","numIlen","numJlen","_removeAffixComments","lines","split","definitionParts","ruleType","ruleCode","combineable","parseInt","entries","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","str","replace","_removeDicComments","addWord","key","el","parts","word","ruleCodesArray","NEEDAFFIX","indexOf","code","newWords","_applyRule","newWord","k","combineCode","combineRule","type","otherNewWords","otherNewWord","trim","continuationRule","concat","textCodes","FLAG","pFlags","substr","aWord","trimmedWord","checkExact","toUpperCase","capitalizedWord","substring","toLowerCase","hasFlag","lowercaseWord","ruleCodes","COMPOUNDMIN","strFlag","wordFlags","flattenArr","arr","ar","a","s","tableItem","limit","memoizedLimit","slice","check","replacementEntry","correctedWord","edits1","words","knownOnly","rv","numLen","strEdit","wrd","strSub","correct","ed1","ed2","weightedCorrections","ed1word","sortedCorrections","sorter","b","aVal","bVal","localeCompare","sort","reverse","capitalizationScheme","workingLimit","Math","min","sortString","update","T"],"mappings":"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"}